"""
인덱싱 서비스 모듈 (리팩토링됨)

이 파일은 호환성을 위해 유지됩니다.
실제 구현은 app/services/indexer/ 디렉토리로 이동되었습니다.
"""

# 리팩토링된 인덱서 서비스 가져오기
from app.services.indexer import indexer_service

# 업데이트 함수 가져오기
from app.services.indexer.base import update_fts_index

import os
import re
import json
import time
import shutil
from pathlib import Path
from datetime import datetime
from threading import Thread
from concurrent.futures import ThreadPoolExecutor, as_completed
import pysrt
from langdetect import detect, LangDetectException
import traceback

from app.config import config
from app.database import db
from app.utils import (
    time_to_ms, remove_html_tags, detect_encoding, is_english_subtitle,
    get_file_extension, get_media_paths, get_estimated_completion_time,
    INDEXING_STATUS_FILE, DEFAULT_MAX_THREADS, MAX_LOG_ENTRIES
)
from app.utils.logging import get_indexer_logger

# 로거 설정
logger = get_indexer_logger()


# FTS 인덱스 업데이트 함수
def update_fts_index(force: bool = False):
    """
    자막 변환 후 FTS 인덱스 업데이트
    
    Args:
        force: FTS 인덱스를 강제로 재구축할지 여부
        
    Returns:
        bool: 성공 여부
    """
    try:
        from app.database.subtitles import get_subtitle_count, rebuild_fts_index
        from app.database.connection import fetch_one
        
        logger.info("FTS 인덱스 업데이트 시작...")
        start_time = time.time()
        
        # subtitles 테이블의 레코드 수
        subtitles_count = get_subtitle_count()
        
        # FTS 테이블의 레코드 수
        fts_result = fetch_one("SELECT COUNT(*) as count FROM subtitles_fts")
        fts_count = fts_result["count"] if fts_result else 0
        
        # 불일치 확인
        is_inconsistent = subtitles_count != fts_count
        
        if force or is_inconsistent:
            if is_inconsistent and not force:
                logger.warning(f"FTS 인덱스와 subtitles 테이블 불일치 발견: subtitles={subtitles_count}, fts={fts_count}")
            
            # FTS 인덱스 재구축
            result = rebuild_fts_index(force=True)
            end_time = time.time()
            
            if result:
                logger.info(f"FTS 인덱스 재구축 완료 ({end_time - start_time:.2f}초)")
                return True
            else:
                logger.error("FTS 인덱스 재구축 실패")
                return False
        else:
            logger.info("FTS 인덱스가 이미 일치합니다. 재구축이 필요하지 않습니다.")
            return True
    except Exception as e:
        logger.error(f"FTS 인덱스 업데이트 실패: {e}")
        # 디버깅을 위한 스택 트레이스 출력
        logger.error(traceback.format_exc())
        return False


class IndexerService:
    """인덱싱 서비스 클래스"""
    
    def __init__(self):
        """인덱서 초기화"""
        self.status_file = INDEXING_STATUS_FILE
        self.current_status = self._load_status() or {
            "is_indexing": False,
            "processed_files": 0,
            "total_files": 0,
            "current_file": "",
            "subtitle_count": 0,
            "log_messages": [],
            "pid": None,
            "last_updated": None,
            "retry_count": 0,  # 재시도 횟수 추가
            "last_error": None  # 마지막 오류 추가
        }
        self.is_paused = False
        self.indexing_thread = None
        
        # 서버 시작 시 이전 인덱싱 상태 확인
        self._check_running_indexing()
    
    def _load_status(self):
        """저장된 인덱싱 상태 로드"""
        try:
            if os.path.exists(self.status_file):
                with open(self.status_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"상태 파일 로딩 오류: {str(e)}")
        return None
    
    def _save_status(self):
        """현재 인덱싱 상태를 파일에 저장"""
        try:
            # 현재 시간 추가
            self.current_status["last_updated"] = datetime.now().isoformat()
            self.current_status["is_paused"] = self.is_paused
            
            with open(self.status_file, 'w', encoding='utf-8') as f:
                json.dump(self.current_status, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"상태 저장 오류: {str(e)}")
    
    def _check_running_indexing(self):
        """서버 시작 시 이전 인덱싱 프로세스 확인"""
        if self.current_status.get("is_indexing") and self.current_status.get("pid"):
            pid = self.current_status.get("pid")
            # PID가 여전히 실행 중인지 확인
            try:
                if os.name == 'nt':  # Windows
                    import ctypes
                    kernel32 = ctypes.windll.kernel32
                    handle = kernel32.OpenProcess(1, False, pid)
                    if handle == 0:
                        self._reset_indexing_status("이전 인덱싱 프로세스가 종료됨")
                    else:
                        kernel32.CloseHandle(handle)
                else:  # Unix/Linux/MacOS
                    os.kill(pid, 0)
            except (OSError, ProcessLookupError):
                # 프로세스가 존재하지 않음
                self._reset_indexing_status("이전 인덱싱 프로세스가 종료됨")
            else:
                # 마지막 업데이트 시간 확인
                if self.current_status.get("last_updated"):
                    try:
                        last_updated = datetime.fromisoformat(self.current_status["last_updated"])
                        now = datetime.now()
                        if (now - last_updated).total_seconds() > 300:  # 5분 이상 업데이트 없음
                            self._reset_indexing_status("인덱싱 프로세스가 응답하지 않음 (5분 이상 업데이트 없음)")
                    except (ValueError, TypeError):
                        pass
    
    def _reset_indexing_status(self, reason="완료"):
        """인덱싱 상태 초기화"""
        self.log("WARNING", f"인덱싱 상태 초기화: {reason}")
        self.current_status["is_indexing"] = False
        self.current_status["pid"] = None
        self.current_status["status_message"] = f"인덱싱 {reason}"
        self.current_status["percentage"] = 100 if reason == "완료" else 0
        self.current_status["is_paused"] = False
        self.current_status["retry_count"] = 0  # 재시도 횟수 초기화
        self.current_status["last_error"] = None  # 마지막 오류 초기화
        self._save_status()
    
    def log(self, level, message):
        """로그 메시지 추가 및 파일에 기록"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"{timestamp} {level}: {message}"
        
        # 상태 메모리에 로그 추가
        self.current_status["log_messages"].insert(0, log_entry)
        
        # 최대 MAX_LOG_ENTRIES개의 로그만 유지
        if len(self.current_status["log_messages"]) > MAX_LOG_ENTRIES:
            self.current_status["log_messages"].pop()
            
        # 로깅 모듈을 사용하여 파일에 로그 기록
        level_upper = level.upper()
        if level_upper == "INFO":
            logger.info(message)
        elif level_upper == "WARNING":
            logger.warning(message)
        elif level_upper == "ERROR":
            logger.error(message)
        elif level_upper == "DEBUG":
            logger.debug(message)
        elif level_upper == "CRITICAL":
            logger.critical(message)
        else:
            # 기본값은 INFO
            logger.info(message)
            
        # 로그 추가할 때마다 상태 저장
        self._save_status()
    
    def log_indexing_event(self, event_type, details=None):
        """인덱싱 이벤트 로깅"""
        if event_type == "start":
            self.log("INFO", "인덱싱 시작")
        elif event_type == "complete":
            self.log("INFO", f"인덱싱 완료: {details.get('processed_files', 0)}개 파일 처리, {details.get('subtitle_count', 0)}개 자막 인덱싱됨")
        elif event_type == "file_start":
            self.log("INFO", f"파일 처리 중: {details.get('file_path', '')}")
        elif event_type == "file_complete":
            self.log("INFO", f"파일 처리 완료: {details.get('file_path', '')}")
        elif event_type == "subtitle_found":
            self.log("INFO", f"자막 발견: {details.get('subtitle_path', '')}")
        elif event_type == "subtitle_processed":
            self.log("INFO", f"자막 처리 완료: {details.get('subtitle_path', '')}, {details.get('lines_count', 0)}개 라인")
        elif event_type == "error":
            self.log("ERROR", f"오류 발생: {details.get('message', '')}")
        elif event_type == "skipped":
            self.log("INFO", f"건너뜀: {details.get('file_path', '')}, 사유: {details.get('reason', '')}")
    
    def get_status(self):
        """현재 인덱싱 상태 반환"""
        # ETA 계산 추가
        if self.current_status["is_indexing"]:
            processed = self.current_status["processed_files"]
            total = max(1, self.current_status["total_files"])  # 0으로 나누기 방지
            
            # 진행률 계산
            progress = min(100, int((processed / total) * 100))
            self.current_status["progress"] = progress
            
            # 예상 완료 시간 계산
            if processed > 0:
                try:
                    # 시작 시간이 저장되어 있으면 사용
                    if "start_time" in self.current_status:
                        start_time = datetime.fromisoformat(self.current_status["start_time"])
                        eta = get_estimated_completion_time(processed, total, start_time)
                        if eta:
                            self.current_status["eta"] = eta
                        else:
                            self.current_status["eta"] = "계산 중..."
                except Exception:
                    self.current_status["eta"] = "계산 중..."
        
        return self.current_status
    
    def start_indexing(self, incremental=True):
        """인덱싱 작업 시작, incremental이 True이면 증분 인덱싱 수행"""
        if self.current_status["is_indexing"]:
            return {"error": "이미 인덱싱이 진행 중입니다."}

        # 일시정지 상태에서 재개하는 경우
        if self.is_paused:
            return self.resume_indexing()

        # 새로운 인덱싱 시작
        self.current_status = {
            "is_indexing": True,
            "is_paused": False,
            "processed_files": 0,
            "total_files": 0,
            "current_file": "",
            "subtitle_count": 0,
            "log_messages": [],
            "pid": os.getpid(),
            "start_time": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat(),
            "incremental": incremental,
            "retry_count": 0,  # 재시도 횟수 추가
            "last_error": None  # 마지막 오류 추가
        }
        
        self.log("INFO", f"인덱싱 시작 (증분 모드: {incremental})")
        self._save_status()
        
        # 인덱싱 스레드 시작
        self.indexing_thread = Thread(target=self._indexing_worker, args=(incremental,))
        self.indexing_thread.daemon = True
        self.indexing_thread.start()
        
        return {"status": "started", "message": "인덱싱이 시작되었습니다."}
    
    def stop_indexing(self):
        """인덱싱 작업 중지"""
        if not self.current_status["is_indexing"]:
            return {"error": "현재 인덱싱이 진행 중이 아닙니다."}
        
        self.log("INFO", "인덱싱 중지 요청")
        self.current_status["is_indexing"] = False
        self._save_status()
        
        return {"status": "stopped", "message": "인덱싱이 중지되었습니다."}
    
    def pause_indexing(self):
        """인덱싱 작업 일시 중지"""
        if not self.current_status["is_indexing"]:
            return {"error": "현재 인덱싱이 진행 중이 아닙니다."}
        
        if self.is_paused:
            return {"error": "이미 일시 중지된 상태입니다."}
        
        self.is_paused = True
        self.log("INFO", "인덱싱 일시 중지")
        self._save_status()
        
        return {"status": "paused", "message": "인덱싱이 일시 중지되었습니다."}
    
    def resume_indexing(self):
        """일시 중지된 인덱싱 작업 재개"""
        if not self.is_paused:
            return {"error": "일시 중지된 인덱싱이 없습니다."}
        
        self.is_paused = False
        self.current_status["is_indexing"] = True
        self.log("INFO", "인덱싱 재개")
        self._save_status()
        
        # 스레드가 종료된 경우 재시작
        if not self.indexing_thread or not self.indexing_thread.is_alive():
            incremental = self.current_status.get("incremental", True)
            self.indexing_thread = Thread(target=self._indexing_worker, args=(incremental,))
            self.indexing_thread.daemon = True
            self.indexing_thread.start()
        
        return {"status": "resumed", "message": "인덱싱이 재개되었습니다."}
    
    def scan_directory(self, incremental=True):
        """
        지정된 디렉토리를 스캔하여 미디어 파일 목록 생성
        
        Args:
            incremental (bool): 증분 인덱싱 여부
            
        Returns:
            list: 처리할 미디어 파일 목록
        """
        root_dir = config.get("root_dir", "")
        if not root_dir or not os.path.exists(root_dir):
            self.log("ERROR", f"루트 디렉토리가 존재하지 않습니다: {root_dir}")
            return []
        
        media_extensions = config.get("media_extensions", [".mp4", ".mkv", ".avi"])
        subtitle_extension = config.get("subtitle_extension", ".srt")
        
        # 이미 인덱싱된 파일 목록 (증분 인덱싱에 사용)
        indexed_files = set()
        if incremental:
            from app.database.media import get_indexed_media_paths
            indexed_files = set(get_indexed_media_paths())
            self.log("INFO", f"이미 인덱싱된 파일: {len(indexed_files)}개")
        
        media_files = []
        total_scanned = 0
        
        self.log("INFO", f"디렉토리 스캔 시작: {root_dir}")
        
        # 모든 파일 스캔
        for dirpath, dirnames, filenames in os.walk(root_dir):
            for filename in filenames:
                if self.is_paused:
                    while self.is_paused and self.current_status["is_indexing"]:
                        time.sleep(1)
                
                if not self.current_status["is_indexing"]:
                    self.log("INFO", "스캔 중지됨")
                    return media_files
                
                filepath = os.path.join(dirpath, filename)
                file_ext = get_file_extension(filepath)
                
                # 미디어 파일 확인
                if file_ext in media_extensions:
                    total_scanned += 1
                    
                    # 증분 인덱싱이고 이미 인덱싱된 파일이면 건너뜀
                    if incremental and filepath in indexed_files:
                        continue
                    
                    # 매칭되는 자막 파일 확인
                    media_path, subtitle_path = get_media_paths(filepath, subtitle_extension)
                    
                    # 자막 파일이 존재하면 목록에 추가
                    if subtitle_path and os.path.exists(subtitle_path):
                        media_files.append({
                            "media_path": media_path,
                            "subtitle_path": subtitle_path
                        })
        
        self.log("INFO", f"디렉토리 스캔 완료: 총 {total_scanned}개 미디어 파일 발견, {len(media_files)}개 새 파일 처리 예정")
        
        return media_files
    
    def thread_safe_process_subtitle(self, subtitle_path, media_id):
        """
        스레드 안전하게 자막 파일 처리 및 데이터베이스에 저장
        병렬 처리를 위해 각 스레드가 자신만의 데이터베이스 연결을 사용하도록 합니다.
        
        Args:
            subtitle_path (str): 자막 파일 경로
            media_id (int): 미디어 파일 ID
            
        Returns:
            int: 처리된 자막 라인 수
        """
        from app.database.connection import connection_context
        
        try:
            # 처리 시작 로깅
            self.log("DEBUG", f"자막 처리 시작: {subtitle_path}")
            
            # 파일 존재 확인
            if not os.path.exists(subtitle_path):
                self.log("ERROR", f"자막 파일이 존재하지 않습니다: {subtitle_path}")
                return 0
                
            # 파일 크기 확인 - 0바이트 파일은 건너뜀
            if os.path.getsize(subtitle_path) == 0:
                self.log("WARNING", f"빈 자막 파일입니다: {subtitle_path}")
                return 0
            
            # 파일 인코딩 탐지
            encoding = detect_encoding(subtitle_path)
            self.log("DEBUG", f"자막 파일 인코딩 감지: {encoding} - {subtitle_path}")
            
            # 변환된 임시 파일 경로
            temp_subtitle_path = None
            
            # 다양한 인코딩 시도
            encodings_to_try = [
                encoding,  # 감지된 인코딩 먼저 시도
                'utf-8', 'utf-8-sig',  # UTF-8 버전들
                'euc-kr', 'cp949',     # 한국어 인코딩
                'latin-1', 'iso-8859-1', # 서양어 인코딩
                'ascii'                 # 기본 ASCII
            ]
            
            # 중복 제거
            encodings_to_try = list(dict.fromkeys(encodings_to_try))
            
            # 인코딩 순회적으로 시도
            subtitles = None
            success_encoding = None
            
            for enc in encodings_to_try:
                try:
                    # 자막 파일 로드 시도
                    subtitles = pysrt.open(subtitle_path, encoding=enc)
                    success_encoding = enc
                    self.log("INFO", f"인코딩 '{enc}'로 자막 파일 로드 성공 - {subtitle_path}")
                    break
                except UnicodeDecodeError:
                    continue
                except Exception as e:
                    self.log("DEBUG", f"인코딩 '{enc}' 시도 중 오류: {str(e)}")
                    continue
            
            # 모든 인코딩 시도 실패 시 자막 변환 모듈 사용
            if subtitles is None:
                self.log("WARNING", f"모든 인코딩 시도 실패 - {subtitle_path}")
                self.log("INFO", f"자막 변환 모듈을 사용하여 재시도합니다 - {subtitle_path}")
                
                # 자막 변환 모듈 임포트
                from app.subtitle.encodings.converter import convert_subtitle_encoding
                import tempfile
                
                # 임시 디렉토리 생성
                temp_dir = tempfile.mkdtemp(prefix="subtitle_convert_")
                
                # 기본 변환 설정
                conversion_config = {
                    'media_dir': os.path.dirname(subtitle_path),
                    'output_dir': temp_dir,
                    'delete_original': False,  # 원본 파일 유지
                    'convert_broken': True,    # 깨진 인코딩 변환
                    'extract_english': False,  # 영어 자막 추출 안 함
                    'process_multi': False     # 다중 언어 처리 안 함
                }
                
                # 자막 변환 실행
                result = convert_subtitle_encoding(subtitle_path, conversion_config)
                
                if result and 'output_path' in result and result['output_path'] and os.path.exists(result['output_path']):
                    temp_subtitle_path = result['output_path']
                    self.log("INFO", f"자막 변환 성공: {result.get('encoding', '알 수 없음')} -> utf-8 ({result.get('status', '?')}) - {subtitle_path} -> {temp_subtitle_path}")
                    
                    # 변환된 파일로 다시 시도
                    try:
                        subtitles = pysrt.open(temp_subtitle_path, encoding='utf-8')
                    except Exception as conv_err:
                        self.log("ERROR", f"변환된 자막 파일 로드 실패: {str(conv_err)} - {temp_subtitle_path}")
                        # 임시 파일 정리
                        if os.path.exists(temp_dir):
                            try:
                                shutil.rmtree(temp_dir)
                            except Exception as rm_err:
                                self.log("WARNING", f"임시 디렉토리 삭제 실패: {str(rm_err)} - {temp_dir}")
                        return 0
                else:
                    self.log("ERROR", f"자막 변환 실패 - {subtitle_path}")
                    # 임시 파일 정리
                    if 'temp_dir' in locals() and os.path.exists(temp_dir):
                        try:
                            shutil.rmtree(temp_dir)
                        except Exception as rm_err:
                            self.log("WARNING", f"임시 디렉토리 삭제 실패: {str(rm_err)} - {temp_dir}")
                    return 0
            
            # 자막이 로드되지 않았으면 0 반환
            if not subtitles:
                self.log("ERROR", f"자막을 로드할 수 없습니다: {subtitle_path}")
                return 0
                
            # 자막 라인이 없거나 비어있는 경우
            if len(subtitles) == 0:
                self.log("WARNING", f"자막 라인이 없습니다: {subtitle_path}")
                return 0
            
            # 자막 중복 제거를 위한 해시 세트
            processed_lines = set()
            subtitles_count = 0
            
            # 자막 라인 처리
            from app.database.subtitles import insert_subtitle
            
            # 처리 시간 제한 - 매우 큰 파일의 경우
            max_processing_time = 600  # 최대 10분
            start_time = time.time()
            
            for subtitle in subtitles:
                # 최대 처리 시간 초과 확인
                if time.time() - start_time > max_processing_time:
                    self.log("WARNING", f"최대 처리 시간 초과, 처리 중단: {subtitle_path}")
                    break
                    
                if not self.current_status["is_indexing"]:
                    break
                    
                # HTML 태그 제거
                text = remove_html_tags(subtitle.text)
                
                # 비어있는 텍스트는 건너뜀
                if not text or text.isspace():
                    continue
                
                # 이미 처리한 텍스트는 건너뛰 (중복 제거)
                if text in processed_lines:
                    continue
                
                processed_lines.add(text)
                
                # 자막 시간 정보 (밀리초 단위)
                start_time_ms = time_to_ms(subtitle.start)
                end_time_ms = time_to_ms(subtitle.end)
                
                # 시간 텍스트 형식 (HH:MM:SS,mmm)
                start_text = str(subtitle.start)
                end_text = str(subtitle.end)
                
                # 자막 라인 저장 - database.subtitles 모듈의 insert_subtitle 함수 사용
                try:
                    insert_subtitle(media_id, start_time_ms, end_time_ms, start_text, end_text, text)
                    subtitles_count += 1
                except Exception as insert_err:
                    self.log("ERROR", f"자막 삽입 중 오류: {str(insert_err)} - {text[:30]}...")
                    # 오류 발생해도 계속 진행
                    continue
            
            # 임시 파일 정리
            if temp_subtitle_path and os.path.exists(os.path.dirname(temp_subtitle_path)):
                try:
                    shutil.rmtree(os.path.dirname(temp_subtitle_path))
                except Exception as clean_err:
                    self.log("WARNING", f"임시 파일 정리 중 오류: {str(clean_err)}")
            
            self.log("INFO", f"자막 처리 완료: {subtitle_path}, {subtitles_count}개 라인 처리됨")
            return subtitles_count
                
        except Exception as e:
            self.log("ERROR", f"자막 처리 중 오류: {str(e)} - {subtitle_path}")
            self.log("ERROR", traceback.format_exc())
            return 0
            
    def _process_parallel(self, media_files):
        """병렬 처리 - 여러 파일을 동시에 처리"""
        try:
            max_workers = min(config.get("max_threads", DEFAULT_MAX_THREADS), 8)  # 최대값 제한
            self.log("INFO", f"병렬 처리 시작 (최대 {max_workers}개 스레드)")
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = []
                
                for file_info in media_files:
                    if not self.current_status["is_indexing"]:
                        break
                        
                    media_path = file_info["media_path"]
                    subtitle_path = file_info["subtitle_path"]
                    
                    # 미디어 파일 정보 저장 - 메인 스레드에서 처리
                    from app.database.media import upsert_media
                    media_id = upsert_media(media_path)
                    
                    # 병렬 작업 제출 - 스레드 안전한 버전 사용
                    future = executor.submit(self.thread_safe_process_subtitle, subtitle_path, media_id)
                    futures.append((future, media_path))
                
                # 완료된 작업 처리
                for i, (future, media_path) in enumerate(futures):
                    if not self.current_status["is_indexing"]:
                        break
                        
                    try:
                        # 현재 파일 표시
                        self.current_status["current_file"] = media_path
                        self.log("INFO", f"처리 중 ({i+1}/{len(futures)}): {media_path}")
                        
                        subtitles_count = future.result()
                        
                        # 상태 업데이트
                        self.current_status["processed_files"] += 1
                        self.current_status["subtitle_count"] += subtitles_count
                        self._save_status()
                        
                        self.log("INFO", f"완료: {media_path} - {subtitles_count}개 자막 인덱싱됨")
                        
                    except Exception as e:
                        self.log("ERROR", f"파일 처리 중 오류: {str(e)} - {media_path}")
                        self.log("ERROR", traceback.format_exc())
                    
        except Exception as e:
            self.log("ERROR", f"병렬 처리 중 오류 발생: {str(e)}")
            self.log("ERROR", traceback.format_exc())
    
    def _process_standard(self, media_files):
        """표준 인덱싱 처리 - 파일을 하나씩 순차적으로 처리"""
        self.log("INFO", f"표준 인덱싱 시작: {len(media_files)}개 파일 처리 예정")
        
        # 진행 상황 표시 변수
        total_files = len(media_files)
        process_start_time = time.time()
        last_progress_log = time.time()
        progress_interval = 30  # 진행 상황 로그 간격 (초)
        
        for i, file_info in enumerate(media_files):
            if not self.current_status["is_indexing"]:
                self.log("INFO", "인덱싱 중지 요청으로 처리 중단")
                break
                
            # 일시 중지 확인
            while self.is_paused and self.current_status["is_indexing"]:
                time.sleep(1)
                
            media_path = file_info["media_path"]
            subtitle_path = file_info["subtitle_path"]
            
            self.current_status["current_file"] = media_path
            self.log("INFO", f"처리 중 ({i+1}/{total_files}): {media_path}")
            
            try:
                # 미디어 파일 정보 저장
                from app.database.media import upsert_media
                media_id = upsert_media(media_path)
                
                # 자막 처리 - 표준 처리에서도 스레드 안전 버전 사용
                subtitles_count = self.thread_safe_process_subtitle(subtitle_path, media_id)
                
                # 상태 업데이트
                self.current_status["processed_files"] += 1
                self.current_status["subtitle_count"] += subtitles_count
                self._save_status()
                
                self.log("INFO", f"완료: {media_path} - {subtitles_count}개 자막 인덱싱됨")
                
            except Exception as e:
                self.log("ERROR", f"파일 처리 중 오류: {str(e)} - {media_path}")
                self.log("ERROR", traceback.format_exc())
                
                # 오류가 발생해도 처리된 파일 수 증가
                self.current_status["processed_files"] += 1
                self._save_status()
                
                # 오류 발생 후 잠시 대기 (0.5초)
                time.sleep(0.5)
            
            # 진행 상황 로그 추가
            if time.time() - last_progress_log >= progress_interval:
                elapsed_time = time.time() - process_start_time
                if i > 0 and elapsed_time > 0:
                    files_per_second = i / elapsed_time
                    estimated_total_time = total_files / files_per_second if files_per_second > 0 else 0
                    estimated_remaining = max(0, estimated_total_time - elapsed_time)
                    
                    # 시간 형식 변환
                    elapsed_str = self._format_time(elapsed_time)
                    remaining_str = self._format_time(estimated_remaining)
                    
                    progress = int((i / total_files) * 100)
                    self.current_status["progress"] = progress
                    self.current_status["status_message"] = f"인덱싱 진행 중: {progress}%"
                    self._save_status()
                    
                    self.log("INFO", f"진행 상황: {i}/{total_files} ({progress}%), "
                                     f"경과: {elapsed_str}, 예상 남은 시간: {remaining_str}")
                last_progress_log = time.time()
    
    def _process_batch(self, media_files):
        """배치 처리 - 미디어 파일을 먼저 모두 등록한 후 자막 처리"""
        try:
            # 1단계: 모든 미디어 파일을 데이터베이스에 등록
            self.log("INFO", "1단계: 미디어 파일 등록 중...")
            media_ids = {}
            
            for i, file_info in enumerate(media_files):
                if not self.current_status["is_indexing"]:
                    return
                    
                media_path = file_info["media_path"]
                from app.database.media import upsert_media
                media_id = upsert_media(media_path)
                media_ids[media_path] = media_id
                
                if i % 10 == 0:  # 진행 상황 주기적 업데이트
                    self.log("INFO", f"미디어 파일 등록 진행 중: {i+1}/{len(media_files)}")
            
            # 2단계: 자막 처리
            self.log("INFO", "2단계: 자막 처리 중...")
            for i, file_info in enumerate(media_files):
                if not self.current_status["is_indexing"]:
                    return
                    
                media_path = file_info["media_path"]
                subtitle_path = file_info["subtitle_path"]
                
                self.current_status["current_file"] = media_path
                self.log("INFO", f"처리 중 ({i+1}/{len(media_files)}): {media_path}")
                
                try:
                    # 자막 처리 - 스레드 안전 버전 사용
                    subtitles_count = self.thread_safe_process_subtitle(subtitle_path, media_ids[media_path])
                    
                    # 상태 업데이트
                    self.current_status["processed_files"] += 1
                    self.current_status["subtitle_count"] += subtitles_count
                    self._save_status()
                    
                    self.log("INFO", f"완료: {media_path} - {subtitles_count}개 자막 인덱싱됨")
                    
                except Exception as e:
                    self.log("ERROR", f"파일 처리 중 오류: {str(e)} - {media_path}")
                    self.log("ERROR", traceback.format_exc())
        except Exception as e:
            self.log("ERROR", f"배치 처리 중 오류 발생: {str(e)}")
            self.log("ERROR", traceback.format_exc())
            
    def _process_delayed_language(self, media_files):
        """지연 언어 감지 처리 - 언어 감지를 최소화"""
        try:
            # 자막 파일 먼저 필터링
            self.log("INFO", "자막 파일 필터링 중...")
            filtered_files = []
            
            for file_info in media_files:
                if not self.current_status["is_indexing"]:
                    break
                    
                media_path = file_info["media_path"]
                subtitle_path = file_info["subtitle_path"]
                
                try:
                    # 자막 파일이 영어인지 확인
                    if is_english_subtitle(subtitle_path):
                        filtered_files.append(file_info)
                    else:
                        self.log("INFO", f"영어 자막이 아님, 건너뜀: {subtitle_path}")
                except Exception as e:
                    self.log("ERROR", f"자막 언어 확인 중 오류: {str(e)} - {subtitle_path}")
            
            # 필터링된 파일 처리
            self.log("INFO", f"영어 자막 파일 {len(filtered_files)}개 처리 중...")
            
            for i, file_info in enumerate(filtered_files):
                if not self.current_status["is_indexing"]:
                    break
                    
                media_path = file_info["media_path"]
                subtitle_path = file_info["subtitle_path"]
                
                self.current_status["current_file"] = media_path
                self.log("INFO", f"처리 중 ({i+1}/{len(filtered_files)}): {media_path}")
                
                try:
                    # 미디어 파일 정보 저장
                    from app.database.media import upsert_media
                    media_id = upsert_media(media_path)
                    
                    # 자막 처리 - 스레드 안전 버전 사용
                    subtitles_count = self.thread_safe_process_subtitle(subtitle_path, media_id)
                    
                    # 상태 업데이트
                    self.current_status["processed_files"] += 1
                    self.current_status["subtitle_count"] += subtitles_count
                    self._save_status()
                    
                    self.log("INFO", f"완료: {media_path} - {subtitles_count}개 자막 인덱싱됨")
                    
                except Exception as e:
                    self.log("ERROR", f"파일 처리 중 오류: {str(e)} - {media_path}")
                    self.log("ERROR", traceback.format_exc())
        except Exception as e:
            self.log("ERROR", f"지연 언어 감지 처리 중 오류 발생: {str(e)}")
            self.log("ERROR", traceback.format_exc())
    
    def _indexing_worker(self, incremental=True):
        """
        인덱싱 작업 수행 (스레드에서 실행)
        
        Args:
            incremental (bool): 증분 인덱싱 여부
        """
        # 설정에서 재시도 관련 값 가져오기
        max_retries = config.get("indexer_retry_count", 3)
        retry_interval = config.get("indexer_retry_interval", 10)
        auto_restart = config.get("auto_restart_indexing", True)
        
        retry_count = 0
        
        # 자동 재시작이 비활성화된 경우 재시도 없이 진행
        if not auto_restart:
            max_retries = 0
        
        while retry_count <= max_retries:
            try:
                if retry_count > 0:
                    self.log("WARNING", f"인덱싱 재시도 중... (시도 {retry_count}/{max_retries})")
                    self.current_status["status_message"] = f"인덱싱 재시도 중 ({retry_count}/{max_retries})"
                    self.current_status["retry_count"] = retry_count
                    self._save_status()
                
                # 미디어 파일 스캔
                media_files = self.scan_directory(incremental)
                self.current_status["total_files"] = len(media_files)
                self._save_status()
                
                if not media_files:
                    self.log("INFO", "처리할 미디어 파일이 없습니다.")
                    self.current_status["is_indexing"] = False
                    self._save_status()
                    return
                
                # 인덱싱 전략 선택
                indexing_strategy = config.get("indexing_strategy", "standard")
                self.log("INFO", f"인덱싱 전략: {indexing_strategy}")
                
                if indexing_strategy == "batch":
                    self._process_batch(media_files)
                elif indexing_strategy == "parallel":
                    self._process_parallel(media_files)
                elif indexing_strategy == "delayed_language":
                    self._process_delayed_language(media_files)
                else:  # 기본: standard
                    self._process_standard(media_files)
                
                # 인덱싱이 중단되었는지 확인
                if not self.current_status["is_indexing"]:
                    self.log("INFO", "인덱싱이 중단되었습니다.")
                    return
                
                # FTS 인덱스 구축
                try:
                    self.log("INFO", "FTS 인덱스 재구축 중...")
                    from app.database.subtitles import rebuild_fts_index
                    
                    # FTS 인덱스 재구축 시도
                    result = rebuild_fts_index(force=False)
                    if result:
                        self.log("INFO", "FTS 인덱스 재구축 완료")
                    else:
                        self.log("WARNING", "FTS 인덱스 재구축 중 문제가 발생했습니다.")
                except Exception as fts_error:
                    self.log("ERROR", f"FTS 인덱스 재구축 중 오류 발생: {str(fts_error)}")
                    self.log("ERROR", traceback.format_exc())
                
                # 인덱싱 완료 처리
                self._reset_indexing_status("완료")
                self.log("INFO", "인덱싱 완료")
                
                # 성공적으로 완료되면 루프 종료
                break
                
            except Exception as e:
                retry_count += 1
                self.current_status["retry_count"] = retry_count
                self.current_status["last_error"] = str(e)
                self._save_status()
                
                error_message = f"인덱싱 작업 중 오류 발생: {str(e)}"
                self.log("ERROR", error_message)
                self.log("DEBUG", traceback.format_exc())
                
                # 최대 재시도 횟수를 초과하면 종료
                if retry_count > max_retries:
                    self.log("ERROR", f"최대 재시도 횟수({max_retries})를 초과하여 인덱싱을 중단합니다.")
                    self._reset_indexing_status("오류로 중단")
                    return
                
                # 재시도 대기
                self.log("INFO", f"{retry_interval}초 후 재시도합니다.")
                self.current_status["status_message"] = f"오류 발생, {retry_interval}초 후 재시도합니다. ({retry_count}/{max_retries})"
                self._save_status()
                time.sleep(retry_interval)
                
                # 인덱싱이 중지되었는지 확인
                if not self.current_status["is_indexing"]:
                    self.log("INFO", "인덱싱이 중지되었습니다.")
                    return
    
    def _format_time(self, seconds):
        """시간(초)을 읽기 쉬운 형식으로 변환"""
        if seconds < 60:
            return f"{seconds:.1f}초"
        elif seconds < 3600:
            minutes = seconds // 60
            sec = seconds % 60
            return f"{int(minutes)}분 {int(sec)}초"
        else:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            sec = seconds % 60
            return f"{int(hours)}시간 {int(minutes)}분 {int(sec)}초"


# IndexerService의 인스턴스 생성
indexer_service = IndexerService()