"""
미디어 파일 데이터 관리 모듈

미디어 파일의 저장, 조회, 업데이트 등을 담당하는 모듈입니다.
"""

import os
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple

from app.utils.logging import setup_module_logger
from app.config import config
from app.database.connection import get_connection, execute_query, fetch_one, fetch_all

# 로거 초기화
logger = setup_module_logger("database.media")


def get_total_media_count() -> int:
    """
    전체 미디어 파일 수를 반환합니다.
    
    Returns:
        int: 전체 미디어 파일 수
    """
    try:
        query = "SELECT COUNT(*) as count FROM media_files"
        result = fetch_one(query)
        return result["count"] if result else 0
    except Exception as e:
        logger.error(f"전체 미디어 파일 수 조회 중 오류: {e}")
        return 0

def insert_media(path: str, has_subtitle: bool = False, 
                size: int = 0, last_modified: Optional[str] = None) -> int:
    """
    미디어 파일 정보 저장
    
    Args:
        path: 미디어 파일 경로
        has_subtitle: 자막 존재 여부
        size: 파일 크기(바이트)
        last_modified: 마지막 수정 시간 (ISO 형식의 문자열)
        
    Returns:
        int: 삽입된 레코드의 ID
    """
    conn = get_connection()
    cursor = conn.cursor()
    
    # 이미 있는지 확인
    cursor.execute('SELECT id FROM media_files WHERE path = ?', (path,))
    existing = cursor.fetchone()
    
    if existing:
        # 업데이트
        cursor.execute(
            'UPDATE media_files SET has_subtitle = ?, size = ?, last_modified = ? WHERE id = ?',
            (has_subtitle, size, last_modified or datetime.now().isoformat(), existing['id'])
        )
        media_id = existing['id']
    else:
        # 새로 삽입
        cursor.execute(
            'INSERT INTO media_files (path, has_subtitle, size, last_modified) VALUES (?, ?, ?, ?)',
            (path, has_subtitle, size, last_modified or datetime.now().isoformat())
        )
        media_id = cursor.lastrowid
    
    conn.commit()
    conn.close()
    return media_id

def upsert_media(media_path: str) -> int:
    """
    미디어 파일 정보 갱신 또는 삽입
    
    Args:
        media_path: 미디어 파일 경로
        
    Returns:
        int: 미디어 파일의 ID
    """
    # 자막 파일 확장자를 config에서 가져오기
    subtitle_extension = config.get('subtitle_extension', '.srt').lower()
    
    # 자막 파일 경로 확인
    subtitle_path = os.path.splitext(media_path)[0] + subtitle_extension
    has_subtitle = os.path.exists(subtitle_path)
    
    # 파일 크기 및 수정 시간
    try:
        file_stat = os.stat(media_path)
        file_size = file_stat.st_size
        file_mtime = datetime.fromtimestamp(file_stat.st_mtime)
        last_modified = file_mtime.isoformat()
    except Exception as e:
        logger.error(f"파일 상태 확인 중 오류: {e}, 경로: {media_path}")
        file_size = 0
        last_modified = datetime.now().isoformat()
    
    # insert_media 메소드 활용
    return insert_media(media_path, has_subtitle, file_size, last_modified)

def get_media_info(media_id: int) -> Optional[Dict[str, Any]]:
    """
    미디어 파일 정보 조회
    
    Args:
        media_id: 미디어 파일 ID
        
    Returns:
        Optional[Dict[str, Any]]: 미디어 파일 정보
    """
    return fetch_one(
        'SELECT id, path, has_subtitle, size, last_modified FROM media_files WHERE id = ?', 
        (media_id,)
    )

def get_media_by_path(path: str) -> Optional[Dict[str, Any]]:
    """
    경로로 미디어 파일 정보 조회
    
    Args:
        path: 미디어 파일 경로
        
    Returns:
        Optional[Dict[str, Any]]: 미디어 파일 정보
    """
    return fetch_one(
        'SELECT id, path, has_subtitle, size, last_modified FROM media_files WHERE path = ?', 
        (path,)
    )

def get_all_media(with_subtitles_only: bool = False, 
                limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
    """
    모든 미디어 파일 정보 조회
    
    Args:
        with_subtitles_only: 자막이 있는 파일만 조회
        limit: 결과 제한 개수
        offset: 결과 시작 위치
        
    Returns:
        List[Dict[str, Any]]: 미디어 파일 정보 목록
    """
    query = """
        SELECT id, path, has_subtitle, size, last_modified 
        FROM media_files
    """
    
    params = []
    
    if with_subtitles_only:
        query += " WHERE has_subtitle = 1"
        
    query += " ORDER BY last_modified DESC LIMIT ? OFFSET ?"
    params.extend([limit, offset])
    
    return fetch_all(query, tuple(params))

def update_subtitle_status(media_id: int, has_subtitle: bool) -> bool:
    """
    미디어 파일의 자막 상태 업데이트
    
    Args:
        media_id: 미디어 파일 ID
        has_subtitle: 자막 존재 여부
        
    Returns:
        bool: 성공 여부
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute(
            'UPDATE media_files SET has_subtitle = ? WHERE id = ?',
            (has_subtitle, media_id)
        )
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger.error(f"자막 상태 업데이트 실패: {e}, 미디어 ID: {media_id}")
        return False

def delete_media(media_id: int) -> bool:
    """
    미디어 파일 정보 삭제
    
    Args:
        media_id: 미디어 파일 ID
        
    Returns:
        bool: 성공 여부
    """
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute('DELETE FROM media_files WHERE id = ?', (media_id,))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger.error(f"미디어 삭제 실패: {e}, 미디어 ID: {media_id}")
        return False

def count_media(with_subtitles_only: bool = False) -> int:
    """
    미디어 파일 수 조회
    
    Args:
        with_subtitles_only: 자막이 있는 파일만 카운트
        
    Returns:
        int: 미디어 파일 수
    """
    query = "SELECT COUNT(*) as count FROM media_files"
    
    if with_subtitles_only:
        query += " WHERE has_subtitle = 1"
    
    result = fetch_one(query)
    return result['count'] if result else 0

def get_media_stats() -> Dict[str, Any]:
    """
    미디어 파일 통계 정보 조회
    
    Returns:
        Dict[str, Any]: 통계 정보
    """
    conn = get_connection()
    cursor = conn.cursor()
    
    # 전체 미디어 수
    cursor.execute("SELECT COUNT(*) as total FROM media_files")
    total = cursor.fetchone()['total']
    
    # 자막 있는 미디어 수
    cursor.execute("SELECT COUNT(*) as with_subtitles FROM media_files WHERE has_subtitle = 1")
    with_subtitles = cursor.fetchone()['with_subtitles']
    
    # 자막 없는 미디어 수
    without_subtitles = total - with_subtitles
    
    # 자막 비율
    subtitle_coverage_percent = round((with_subtitles / total * 100) if total > 0 else 0, 1)
    
    # 확장자별 통계 (Python의 os.path 사용)
    cursor.execute("SELECT path FROM media_files")
    paths = cursor.fetchall()
    
    extensions = {}
    for row in paths:
        file_path = row['path']
        _, file_ext = os.path.splitext(file_path)
        if file_ext:
            file_ext = file_ext[1:].lower()  # 점(.) 제거하고 소문자로 변환
            extensions[file_ext] = extensions.get(file_ext, 0) + 1
    
    # 확장자별로 정렬 (개수 내림차순)
    sorted_extensions = dict(sorted(extensions.items(), key=lambda x: x[1], reverse=True))
    
    conn.close()
    
    return {
        "total": total,
        "with_subtitles": with_subtitles,
        "without_subtitles": without_subtitles,
        "subtitle_coverage_percent": subtitle_coverage_percent,
        "extensions": sorted_extensions
    }

def get_indexed_media_paths() -> List[str]:
    """
    인덱싱된 모든 미디어 파일 경로 목록을 반환합니다.
    
    Returns:
        List[str]: 인덱싱된 미디어 파일 경로 목록
    """
    query = """
        SELECT path FROM media_files
    """
    
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute(query)
        result = [row['path'] for row in cursor.fetchall()]
        conn.close()
        return result
    except Exception as e:
        logger.error(f"인덱싱된 미디어 경로 조회 실패: {e}")
        return []