"""
자막 데이터 관리 모듈

자막 정보의 저장, 조회, 검색 등을 담당하는 모듈입니다.
"""

import os
import sqlite3
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple, Union

from app.utils.logging import setup_module_logger
from app.config import config
from app.database.connection import get_connection, execute_query, fetch_one, fetch_all, connection_context
from app.database.media import update_subtitle_status

# 로거 초기화
logger = setup_module_logger("database.subtitles")


# 자막 파일 정보 관련 함수들

def init_subtitle_db() -> None:
    """
    자막 정보 데이터베이스 초기화 및 필요한 테이블 생성
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # subtitle_files 테이블 생성 - 자막 파일 정보 저장
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS subtitle_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT NOT NULL UNIQUE,
                media_path TEXT,
                encoding TEXT,
                is_broken BOOLEAN DEFAULT 0,
                is_multi BOOLEAN DEFAULT 0,
                is_processed BOOLEAN DEFAULT 0,
                last_checked TEXT,
                created_time TEXT,
                modified_time TEXT,
                file_size INTEGER DEFAULT 0,
                language TEXT,
                has_english BOOLEAN DEFAULT 0
            )
        ''')
        
        # media_subtitles 테이블 생성 - 미디어 파일과 내장 자막 정보 저장
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS media_subtitles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                media_path TEXT NOT NULL,
                has_embedded_subtitle BOOLEAN DEFAULT 0,
                embedded_subtitle_langs TEXT,
                extracted BOOLEAN DEFAULT 0,
                last_checked TEXT,
                UNIQUE(media_path)
            )
        ''')
        
        # subtitle_processing 테이블 생성 - 자막 처리 이력 저장
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS subtitle_processing (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                subtitle_path TEXT NOT NULL,
                process_type TEXT NOT NULL,
                status TEXT NOT NULL,
                processed_at TEXT DEFAULT CURRENT_TIMESTAMP,
                error_message TEXT,
                output_path TEXT
            )
        ''')
        
        # 인덱스 생성
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_subtitle_path ON subtitle_files (path)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_subtitle_media_path ON subtitle_files (media_path)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_media_subtitles_path ON media_subtitles (media_path)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_subtitle_processing_path ON subtitle_processing (subtitle_path)')
        
        conn.commit()
        logger.debug("자막 정보 데이터베이스 초기화 완료")
    except Exception as e:
        logger.error(f"자막 정보 데이터베이스 초기화 오류: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()

def get_subtitle_info(subtitle_path: str) -> Optional[Dict[str, Any]]:
    """
    자막 파일 정보 조회
    
    Args:
        subtitle_path: 자막 파일 경로
        
    Returns:
        Optional[Dict[str, Any]]: 자막 파일 정보 또는 None
    """
    try:
        return fetch_one(
            "SELECT * FROM subtitle_files WHERE path = ?", 
            (subtitle_path,)
        )
    except Exception as e:
        logger.error(f"자막 정보 조회 오류: {e}")
        return None

def save_subtitle_info(subtitle_info: Dict[str, Any]) -> bool:
    """
    자막 파일 정보 저장 또는 업데이트
    
    Args:
        subtitle_info: 자막 파일 정보 딕셔너리
        
    Returns:
        bool: 성공 여부
    """
    conn = None
    try:
        # 필수 필드 확인
        if 'path' not in subtitle_info:
            logger.error("자막 정보 저장 실패: 경로 정보 누락")
            return False
        
        # 현재 시간 설정
        now = datetime.now().isoformat()
        subtitle_info['last_checked'] = now
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # 이미 존재하는지 확인
        cursor.execute(
            "SELECT id FROM subtitle_files WHERE path = ?", 
            (subtitle_info['path'],)
        )
        existing = cursor.fetchone()
        
        if existing:
            # 업데이트
            fields = []
            values = []
            
            for key, value in subtitle_info.items():
                if key != 'path' and key != 'id':
                    fields.append(f"{key} = ?")
                    values.append(value)
            
            values.append(subtitle_info['path'])
            
            query = f"UPDATE subtitle_files SET {', '.join(fields)} WHERE path = ?"
            cursor.execute(query, values)
        else:
            # 새로 삽입
            fields = []
            placeholders = []
            values = []
            
            for key, value in subtitle_info.items():
                fields.append(key)
                placeholders.append('?')
                values.append(value)
            
            query = f"INSERT INTO subtitle_files ({', '.join(fields)}) VALUES ({', '.join(placeholders)})"
            cursor.execute(query, values)
        
        conn.commit()
        return True
    except Exception as e:
        logger.error(f"자막 정보 저장 오류: {e}")
        if conn:
            conn.rollback()
        return False
    finally:
        if conn:
            conn.close()

def get_media_subtitle_info(media_path: str) -> Optional[Dict[str, Any]]:
    """
    미디어 파일의 내장 자막 정보 조회
    
    Args:
        media_path: 미디어 파일 경로
        
    Returns:
        Optional[Dict[str, Any]]: 미디어 파일의 내장 자막 정보 또는 None
    """
    try:
        return fetch_one(
            "SELECT * FROM media_subtitles WHERE media_path = ?", 
            (media_path,)
        )
    except Exception as e:
        logger.error(f"미디어 자막 정보 조회 오류: {e}")
        return None

def save_media_subtitle_info(media_info: Dict[str, Any]) -> bool:
    """
    미디어 파일의 내장 자막 정보 저장 또는 업데이트
    
    Args:
        media_info: 미디어 파일의 내장 자막 정보 딕셔너리
        
    Returns:
        bool: 성공 여부
    """
    conn = None
    try:
        # 필수 필드 확인
        if 'media_path' not in media_info:
            logger.error("미디어 자막 정보 저장 실패: 경로 정보 누락")
            return False
        
        # 현재 시간 설정
        now = datetime.now().isoformat()
        media_info['last_checked'] = now
        
        conn = get_connection()
        cursor = conn.cursor()
        
        # 이미 존재하는지 확인
        cursor.execute(
            "SELECT id FROM media_subtitles WHERE media_path = ?", 
            (media_info['media_path'],)
        )
        existing = cursor.fetchone()
        
        if existing:
            # 업데이트
            fields = []
            values = []
            
            for key, value in media_info.items():
                if key != 'media_path' and key != 'id':
                    fields.append(f"{key} = ?")
                    values.append(value)
            
            values.append(media_info['media_path'])
            
            query = f"UPDATE media_subtitles SET {', '.join(fields)} WHERE media_path = ?"
            cursor.execute(query, values)
        else:
            # 새로 삽입
            fields = []
            placeholders = []
            values = []
            
            for key, value in media_info.items():
                fields.append(key)
                placeholders.append('?')
                values.append(value)
            
            query = f"INSERT INTO media_subtitles ({', '.join(fields)}) VALUES ({', '.join(placeholders)})"
            cursor.execute(query, values)
        
        conn.commit()
        return True
    except Exception as e:
        logger.error(f"미디어 자막 정보 저장 오류: {e}")
        if conn:
            conn.rollback()
        return False
    finally:
        if conn:
            conn.close()

def log_processing(subtitle_path: str, process_type: str, status: str, 
                 error_message: Optional[str] = None, output_path: Optional[str] = None) -> bool:
    """
    자막 처리 이력 기록
    
    Args:
        subtitle_path: 자막 파일 경로
        process_type: 처리 유형
        status: 처리 상태
        error_message: 오류 메시지
        output_path: 출력 파일 경로
        
    Returns:
        bool: 성공 여부
    """
    try:
        return execute_query(
            """
            INSERT INTO subtitle_processing 
            (subtitle_path, process_type, status, processed_at, error_message, output_path)
            VALUES (?, ?, ?, ?, ?, ?)
            """,
            (subtitle_path, process_type, status, datetime.now().isoformat(), error_message, output_path),
            commit=True
        ) is not None
    except Exception as e:
        logger.error(f"자막 처리 이력 기록 오류: {e}")
        return False

def get_unprocessed_subtitles(limit: int = 100) -> List[Dict[str, Any]]:
    """
    처리되지 않은 자막 파일 목록 조회
    
    Args:
        limit: 최대 조회 개수
        
    Returns:
        List[Dict[str, Any]]: 처리되지 않은 자막 파일 목록
    """
    try:
        return fetch_all(
            """
            SELECT * FROM subtitle_files 
WHERE is_processed = 0
            ORDER BY last_checked ASC
            LIMIT ?
            """,
            (limit,)
        )
    except Exception as e:
        logger.error(f"처리되지 않은 자막 목록 조회 오류: {e}")
        return []

def get_broken_subtitles(limit: int = 100) -> List[Dict[str, Any]]:
    """
    깨진 인코딩의 자막 파일 목록 조회
    
    Args:
        limit: 최대 조회 개수
        
    Returns:
        List[Dict[str, Any]]: 깨진 인코딩의 자막 파일 목록
    """
    try:
        return fetch_all(
            """
            SELECT * FROM subtitle_files 
WHERE is_broken = 1 AND is_processed = 0
            ORDER BY last_checked ASC
            LIMIT ?
            """,
            (limit,)
        )
    except Exception as e:
        logger.error(f"깨진 자막 목록 조회 오류: {e}")
        return []

def get_multi_subtitles(limit: int = 100) -> List[Dict[str, Any]]:
    """
    다중 언어 자막 파일 목록 조회
    
    Args:
        limit: 최대 조회 개수
        
    Returns:
        List[Dict[str, Any]]: 다중 언어 자막 파일 목록
    """
    try:
        return fetch_all(
            """
            SELECT * FROM subtitle_files 
WHERE is_multi = 1 AND is_processed = 0
            ORDER BY last_checked ASC
            LIMIT ?
            """,
            (limit,)
        )
    except Exception as e:
        logger.error(f"다중 언어 자막 목록 조회 오류: {e}")
        return []

def get_media_without_subtitles(limit: int = 100) -> List[Dict[str, Any]]:
    """
    자막이 없는 미디어 파일 목록 조회
    
    Args:
        limit: 최대 조회 개수
        
    Returns:
        List[Dict[str, Any]]: 자막이 없는 미디어 파일 목록
    """
    try:
        return fetch_all(
            """
            SELECT * FROM media_subtitles 
WHERE has_embedded_subtitle = 1 AND extracted = 0
            ORDER BY last_checked ASC
            LIMIT ?
            """,
            (limit,)
        )
    except Exception as e:
        logger.error(f"자막 없는 미디어 목록 조회 오류: {e}")
        return []

def get_encoding_stats() -> Dict[str, int]:
    """
    인코딩별 자막 파일 수 통계 가져오기
    
    Returns:
        Dict[str, int]: 인코딩별 자막 파일 수
    """
    try:
        results = fetch_all(
            """
            SELECT encoding, COUNT(*) as count
FROM subtitle_files
            GROUP BY encoding
            ORDER BY count DESC
            """
        )
        
        stats = {}
        for row in results:
            if row['encoding']:  # None 값 건너뛰기
                stats[row['encoding'].lower()] = row['count']
            else:
                stats['unknown'] = row['count']
        
        return stats
    except Exception as e:
        logger.error(f"자막 인코딩 통계 조회 오류: {e}")
        return {}

def get_subtitles_by_encoding(encoding: str, limit: int = 1000) -> List[Dict[str, Any]]:
    """
    특정 인코딩의 자막 파일 목록 가져오기
    
    Args:
        encoding: 인코딩 이름
        limit: 최대 조회 개수
        
    Returns:
        List[Dict[str, Any]]: 특정 인코딩의 자막 파일 목록
    """
    try:
        # 대소문자 구분 없이 인코딩 비교
        return fetch_all(
            """
            SELECT * FROM subtitle_files 
WHERE LOWER(encoding) = LOWER(?)
            LIMIT ?
            """,
            (encoding, limit)
        )
    except Exception as e:
        logger.error(f"특정 인코딩 자막 목록 조회 오류: {e}")
        return []

def get_subtitle_encoding_status() -> Dict[str, Any]:
    """
    자막 인코딩 현황 통계 가져오기
    
    Returns:
        Dict[str, Any]: 자막 인코딩 현황 통계
    """
    try:
        # 전체 자막 파일 수
        total_count = fetch_one("SELECT COUNT(*) as count FROM subtitle_files")
        total = total_count['count'] if total_count else 0
        
        # 인코딩 식별된 자막 수
        encoded_count = fetch_one("SELECT COUNT(*) as count FROM subtitle_files WHERE encoding IS NOT NULL")
        encoded = encoded_count['count'] if encoded_count else 0
        
        # 깨진 인코딩 자막 수
        broken_count = fetch_one("SELECT COUNT(*) as count FROM subtitle_files WHERE is_broken = 1")
        broken = broken_count['count'] if broken_count else 0
        
        # 다중 언어 자막 수
        multi_count = fetch_one("SELECT COUNT(*) as count FROM subtitle_files WHERE is_multi = 1")
        multi = multi_count['count'] if multi_count else 0
        
        # 처리된 자막 수
        processed_count = fetch_one("SELECT COUNT(*) as count FROM subtitle_files WHERE is_processed = 1")
        processed = processed_count['count'] if processed_count else 0
        
        # 인코딩별 통계
        encoding_stats = get_encoding_stats()
        
        return {
            "total": total,
            "encoded": encoded,
            "broken": broken,
            "multi": multi,
            "processed": processed,
            "unprocessed": total - processed,
            "encoding_stats": encoding_stats,
            "percent_encoded": round((encoded / total) * 100, 2) if total > 0 else 0,
            "percent_broken": round((broken / total) * 100, 2) if total > 0 else 0,
            "percent_processed": round((processed / total) * 100, 2) if total > 0 else 0
        }
    except Exception as e:
        logger.error(f"자막 인코딩 현황 통계 조회 오류: {e}")
        return {}

def rebuild_fts_index(force: bool = False) -> bool:
    """
    FTS(Full-Text Search) 인덱스 재구축
    
    Args:
        force: 기존 인덱스를 모두 제거하고 새로 구축할지 여부
        
    Returns:
        bool: 성공 여부
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 트랜잭션 시작
        conn.execute('BEGIN')
        
        # FTS 테이블 존재 확인
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
        fts_exists = cursor.fetchone() is not None
        
        if not fts_exists:
            logger.warning("FTS 테이블이 존재하지 않습니다. 스키마 확인 필요.")
            conn.rollback()
            return False
        
        # 기존 FTS 인덱스 제거 (force=True인 경우)
        if force:
            try:
                cursor.execute('DELETE FROM subtitles_fts')
                logger.info("기존 FTS 인덱스 삭제 완료")
            except Exception as e:
                logger.error(f"FTS 인덱스 삭제 중 오류: {e}")
                conn.rollback()
                return False
        
        # 현재 FTS 인덱스에 있는 자막 ID 목록 가져오기
        try:
            cursor.execute('SELECT docid FROM subtitles_fts')
            indexed_ids = set(row['docid'] for row in cursor.fetchall())
            logger.debug(f"현재 FTS 인덱스에 있는 자막 수: {len(indexed_ids)}")
        except Exception as e:
            logger.error(f"FTS 인덱스 ID 조회 중 오류: {e}")
            conn.rollback()
            return False
        
        # 자막 테이블에서 모든 자막 가져오기
        try:
            cursor.execute('SELECT id, content FROM subtitles')
            all_subtitles = cursor.fetchall()
            logger.debug(f"전체 자막 테이블 레코드 수: {len(all_subtitles)}")
        except Exception as e:
            logger.error(f"자막 테이블 조회 중 오류: {e}")
            conn.rollback()
            return False
        
        # 인덱싱되지 않은 자막만 필터링
        subtitles_to_index = [s for s in all_subtitles if s['id'] not in indexed_ids]
        
        if subtitles_to_index:
            logger.info(f"FTS 인덱스에 {len(subtitles_to_index)}개 자막 추가 중...")
            
            # 대량 삽입 대신 일괄 처리 (청크 단위로 처리)
            chunk_size = 1000  # 한 번에 처리할 최대 자막 수
            for i in range(0, len(subtitles_to_index), chunk_size):
                chunk = subtitles_to_index[i:i + chunk_size]
                values = [(s['id'], s['content']) for s in chunk]
                
                try:
                    # FTS 인덱스에 자막 추가
                    cursor.executemany(
                        'INSERT INTO subtitles_fts(docid, content) VALUES (?, ?)',
                        values
                    )
                    logger.debug(f"FTS 청크 처리: {i}-{i+len(chunk)} / {len(subtitles_to_index)}")
                except Exception as e:
                    logger.error(f"FTS 인덱스 추가 중 오류 (청크 {i}): {e}")
                    conn.rollback()
                    return False
            
            logger.info(f"FTS 인덱스에 {len(subtitles_to_index)}개 자막 추가 완료")
        else:
            logger.info("추가할 새 자막이 없습니다.")
        
        # FTS 인덱스와 자막 테이블의 레코드 수 확인
        try:
            cursor.execute('SELECT COUNT(*) as count FROM subtitles_fts')
            fts_count = cursor.fetchone()['count']
            cursor.execute('SELECT COUNT(*) as count FROM subtitles')
            subtitles_count = cursor.fetchone()['count']
            
            if fts_count != subtitles_count:
                logger.warning(f"FTS 인덱스와 자막 테이블의 레코드 수가 일치하지 않습니다: FTS={fts_count}, subtitles={subtitles_count}")
            else:
                logger.info(f"FTS 인덱스와 자막 테이블의 레코드 수 일치 확인: {fts_count}개")
        except Exception as e:
            logger.error(f"FTS 인덱스 검증 중 오류: {e}")
            # 검증 실패는 트랜잭션을 중단하지 않음 (기존 작업은 유지)
        
        # 트랜잭션 커밋
        conn.commit()
        return True
        
    except Exception as e:
        # 에러 발생 시 롤백
        if conn:
            conn.rollback()
        logger.error(f"FTS 인덱스 재구축 오류: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False
        
    finally:
        if conn:
            conn.close()

def add_subtitle_to_fts(subtitle_id: int, content: str) -> bool:
    """
    단일 자막을 FTS 인덱스에 추가합니다.
    인덱싱 과정에서 새로 추가된 자막을 즉시 검색 가능하게 만듭니다.
    
    Args:
        subtitle_id: 자막 ID
        content: 자막 내용
        
    Returns:
        bool: 성공 여부
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # FTS 테이블 존재 확인
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
        fts_exists = cursor.fetchone() is not None
        
        if not fts_exists:
            logger.warning("FTS 테이블이 존재하지 않아 인덱스 추가를 건너뜁니다.")
            return False
        
        # 이미 존재하는지 확인
        cursor.execute("SELECT docid FROM subtitles_fts WHERE docid = ?", (subtitle_id,))
        existing = cursor.fetchone()
        
        if existing:
            # 이미 존재하면 업데이트
            cursor.execute("UPDATE subtitles_fts SET content = ? WHERE docid = ?", (content, subtitle_id))
            logger.debug(f"자막 ID {subtitle_id} FTS 인덱스 업데이트 완료")
        else:
            # 새로 추가
            cursor.execute("INSERT INTO subtitles_fts(docid, content) VALUES (?, ?)", (subtitle_id, content))
            logger.debug(f"자막 ID {subtitle_id} FTS 인덱스 추가 완료")
        
        conn.commit()
        return True
    except Exception as e:
        if conn:
            conn.rollback()
        logger.error(f"자막 FTS 인덱스 추가 중 오류: {e}")
        return False
    finally:
        if conn:
            conn.close()

def insert_subtitle(media_id: int, start_ms: int, end_ms: int, 
                   start_text: str, end_text: str, content: str, 
                   lang: str = 'en') -> Optional[int]:
    """
    자막 정보 저장
    
    Args:
        media_id: 미디어 파일 ID
        start_ms: 시작 시간 (밀리초)
        end_ms: 종료 시간 (밀리초)
        start_text: 시작 시간 텍스트 (HH:MM:SS,mmm)
        end_text: 종료 시간 텍스트 (HH:MM:SS,mmm)
        content: 자막 내용
        lang: 언어 코드 (기본값: 'en')
        
    Returns:
        Optional[int]: 삽입된 자막 ID 또는 실패 시 None
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 트랜잭션 시작
        conn.execute('BEGIN')
        
        # 자막 테이블에 데이터 삽입
        cursor.execute(
            '''INSERT INTO subtitles 
               (media_id, start_time, end_time, start_time_text, end_time_text, content, lang)
               VALUES (?, ?, ?, ?, ?, ?, ?)''',
            (media_id, start_ms, end_ms, start_text, end_text, content, lang)
        )
        subtitle_id = cursor.lastrowid
        
        logger.debug(f"자막 삽입 성공: ID={subtitle_id}, 미디어ID={media_id}, 내용={content[:30]}...")
        
        # 미디어 파일의 has_subtitle 상태를 true로 업데이트
        cursor.execute('UPDATE media_files SET has_subtitle = 1 WHERE id = ?', (media_id,))
        
        # FTS 인덱스에도 추가 (즉시 검색 가능하게)
        try:
            # FTS 테이블 존재 확인
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
            fts_exists = cursor.fetchone() is not None
            
            if fts_exists and subtitle_id:
                cursor.execute('INSERT INTO subtitles_fts(docid, content) VALUES (?, ?)', (subtitle_id, content))
                logger.debug(f"자막 ID {subtitle_id} FTS 인덱스 추가 완료")
        except Exception as fts_error:
            # FTS 인덱스 추가 실패는 기록만 하고 트랜잭션은 계속 진행 (중요 데이터는 이미 저장됨)
            logger.warning(f"FTS 인덱스 추가 중 오류 (나중에 재구축 필요): {fts_error}")
            # 트랜잭션 커밋은 계속 진행
        
        # 트랜잭션 커밋
        conn.commit()
        return subtitle_id
        
    except Exception as e:
        # 에러 발생 시 롤백
        if conn:
            conn.rollback()
        logger.error(f"자막 삽입 오류: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None
    finally:
        if conn:
            conn.close()



def estimate_total_count(query: str, lang: str = None, start_time: str = None, end_time: str = None, 
                     search_method: str = 'fts') -> int:
    """
    검색 조건에 맞는 총 결과 수 추정

    Args:
        query: 검색어
        lang: 언어 필터
        start_time: 시작 시간 필터 (HH:MM:SS)
        end_time: 종료 시간 필터 (HH:MM:SS)
        search_method: 검색 방식 ('like' 또는 'fts', 기본값: 'fts')
        
    Returns:
        int: 총 결과 수 추정값
    """
    if not query or query.strip() == "":
        return 0
    
    # 검색어 전처리
    query = query.strip()
    
    # 특수 문자 제거 (오류 방지)
    for char in ['"', "'", ";", "--", "/*", "*/", "\\"]:
        query = query.replace(char, " ")
    
    # 빈 검색어 처리
    query = query.strip()
    if not query:
        return 0
    
    try:
        # 검색 방식에 따른 쿼리 작성
        if search_method.lower() == 'fts':
            # FTS 테이블 존재 확인
            fts_exists = fetch_one("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
            if not fts_exists:
                raise ValueError("FTS 테이블이 존재하지 않습니다.")
                
            # FTS 쿼리 작성
            sql = "SELECT COUNT(*) as count FROM subtitles_fts fts JOIN subtitles s ON fts.rowid = s.id WHERE subtitles_fts MATCH ?"
            params = [query]
            
        else:  # 'like' 검색 방식
            # LIKE 쿼리 작성
            sql = "SELECT COUNT(*) as count FROM subtitles s WHERE s.content LIKE ?"
            params = [f"%{query}%"]
        
        # 추가 필터 적용
        if lang:
            sql += " AND s.lang = ?"
            params.append(lang)
            
        # 시간 필터 적용
        if start_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = start_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                start_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.end_ms >= ?"
                params.append(start_ms)
                
        if end_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = end_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                end_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.start_ms <= ?"
                params.append(end_ms)
        
        # 쿼리 실행
        result = fetch_one(sql, tuple(params))
        return result["count"] if result else 0
        
    except Exception as e:
        logger.error(f"검색 결과 수 추정 중 오류 발생: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return 0

def estimate_total_count(query: str, lang: str = None, start_time: str = None, end_time: str = None, 
                     search_method: str = 'fts') -> int:
    """
    검색 조건에 맞는 총 결과 수 추정

    Args:
        query: 검색어
        lang: 언어 필터
        start_time: 시작 시간 필터 (HH:MM:SS)
        end_time: 종료 시간 필터 (HH:MM:SS)
        search_method: 검색 방식 ('like' 또는 'fts', 기본값: 'fts')
        
    Returns:
        int: 총 결과 수 추정값
    """
    if not query or query.strip() == "":
        return 0
    
    # 검색어 전처리
    query = query.strip()
    
    # 특수 문자 제거 (오류 방지)
    for char in ['"', "'", ";", "--", "/*", "*/", "\\"]:
        query = query.replace(char, " ")
    
    # 빈 검색어 처리
    query = query.strip()
    if not query:
        return 0
    
    try:
        # 검색 방식에 따른 쿼리 작성
        if search_method.lower() == 'fts':
            # FTS 테이블 존재 확인
            fts_exists = fetch_one("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
            if not fts_exists:
                raise ValueError("FTS 테이블이 존재하지 않습니다.")
                
            # FTS 쿼리 작성
            sql = "SELECT COUNT(*) as count FROM subtitles_fts fts JOIN subtitles s ON fts.rowid = s.id WHERE subtitles_fts MATCH ?"
            params = [query]
            
        else:  # 'like' 검색 방식
            # LIKE 쿼리 작성
            sql = "SELECT COUNT(*) as count FROM subtitles s WHERE s.content LIKE ?"
            params = [f"%{query}%"]
        
        # 추가 필터 적용
        if lang:
            sql += " AND s.lang = ?"
            params.append(lang)
            
        # 시간 필터 적용
        if start_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = start_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                start_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.end_ms >= ?"
                params.append(start_ms)
                
        if end_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = end_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                end_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.start_ms <= ?"
                params.append(end_ms)
        
        # 쿼리 실행
        result = fetch_one(sql, tuple(params))
        return result["count"] if result else 0
        
    except Exception as e:
        logger.error(f"검색 결과 수 추정 중 오류 발생: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return 0
def search_subtitles(query: str, lang: str = None, start_time: str = None, end_time: str = None, 
                  page: int = 1, per_page: int = 50, search_method: str = 'fts') -> List[Dict[str, Any]]:
    """
    자막 내용 검색

    Args:
        query: 검색어
        lang: 언어 필터
        start_time: 시작 시간 필터 (HH:MM:SS)
        end_time: 종료 시간 필터 (HH:MM:SS)
        page: 페이지 번호 (1부터 시작)
        per_page: 페이지당 결과 수
        search_method: 검색 방식 ('like' 또는 'fts', 기본값: 'fts')
        
    Returns:
        List[Dict[str, Any]]: 검색 결과 목록
    """
    if not query or query.strip() == "":
        return []
    
    # 검색어 전처리
    query = query.strip()
    
    # 특수 문자 제거 (오류 방지)
    for char in ['"', "'", ";", "--", "/*", "*/", "\\"]:
        query = query.replace(char, " ")
    
    # 빈 검색어 처리
    query = query.strip()
    if not query:
        return []
    
    # 페이지네이션 처리
    offset = (page - 1) * per_page
    
    try:
        # 검색 방식에 따른 쿼리 작성
        if search_method.lower() == 'fts':
            # FTS 테이블 존재 확인
            fts_exists = fetch_one("SELECT name FROM sqlite_master WHERE type='table' AND name='subtitles_fts'")
            if not fts_exists:
                raise ValueError("FTS 테이블이 존재하지 않습니다.")
                
            # FTS 쿼리 작성
            sql = "SELECT s.id, s.media_id, s.start_ms, s.end_ms, s.start_text, s.end_text, s.content, s.lang, m.path as media_path, m.has_subtitle FROM subtitles_fts fts JOIN subtitles s ON fts.rowid = s.id JOIN media m ON s.media_id = m.id WHERE subtitles_fts MATCH ?"
            params = [query]
            
        else:  # 'like' 검색 방식
            # LIKE 쿼리 작성
            sql = "SELECT s.id, s.media_id, s.start_ms, s.end_ms, s.start_text, s.end_text, s.content, s.lang, m.path as media_path, m.has_subtitle FROM subtitles s JOIN media m ON s.media_id = m.id WHERE s.content LIKE ?"
            params = [f"%{query}%"]
        
        # 추가 필터 적용
        if lang:
            sql += " AND s.lang = ?"
            params.append(lang)
            
        # 시간 필터 적용
        if start_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = start_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                start_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.end_ms >= ?"
                params.append(start_ms)
                
        if end_time:
            # HH:MM:SS 형식을 밀리초로 변환
            parts = end_time.split(":")
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                end_ms = (hours * 3600 + minutes * 60 + seconds) * 1000
                sql += " AND s.start_ms <= ?"
                params.append(end_ms)
        
        # 정렬 및 페이지네이션
        sql += " ORDER BY s.media_id, s.start_ms LIMIT ? OFFSET ?"
        params.extend([per_page, offset])
        
        # 쿼리 실행
        results = fetch_all(sql, tuple(params))
        return results or []
        
    except Exception as e:
        logger.error(f"자막 검색 중 오류 발생: {str(e)}")
        logger.error(f"SQL: {sql if 'sql' in locals() else '?'}, Params: {params if 'params' in locals() else '?'}")
        import traceback
        logger.error(traceback.format_exc())
        return []
def clear_subtitles_for_media(media_id: int) -> bool:
    """
    특정 미디어의 모든 자막 삭제

    Args:
        media_id: 미디어 파일 ID

    Returns:
        bool: 성공 여부
    """
    conn = None
    try:
        conn = get_connection()
        cursor = conn.cursor()
        
        # 트랜잭션 시작
        conn.execute('BEGIN')
        
        # FTS 테이블에서도 해당 자막들 삭제
        cursor.execute('''
            DELETE FROM subtitles_fts WHERE docid IN (
                SELECT id FROM subtitles WHERE media_id = ?
            )
        ''', (media_id,))
        
        # 자막 테이블에서 삭제
        cursor.execute('DELETE FROM subtitles WHERE media_id = ?', (media_id,))
        
        # 미디어 파일 has_subtitle 상태 업데이트
        cursor.execute('UPDATE media_files SET has_subtitle = 0 WHERE id = ?', (media_id,))
        
        conn.commit()
        logger.debug(f"미디어 ID {media_id}의 자막 삭제 성공")
        return True
        
    except Exception as e:
        if conn:
            conn.rollback()
        logger.error(f"자막 삭제 중 오류 발생: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False
        
    finally:
        if conn:
            conn.close()

def get_subtitles_for_media(media_id: int, limit: int = 1000, offset: int = 0) -> List[Dict[str, Any]]:
    """
    특정 미디어의 자막 목록 조회
    
    Args:
        media_id: 미디어 파일 ID
        limit: 최대 조회 개수
        offset: 조회 시작 위치
        
    Returns:
        List[Dict[str, Any]]: 자막 목록
    """
    try:
        sql = "SELECT * FROM subtitles WHERE media_id = ? ORDER BY start_ms LIMIT ? OFFSET ?"
        params = (media_id, limit, offset)
        
        results = fetch_all(sql, params)
        return results or []
        
    except Exception as e:
        logger.error(f"미디어 ID {media_id}의 자막 조회 중 오류 발생: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return []

def get_subtitle_stats() -> Dict[str, Any]:
    """
    자막 통계 정보 조회
    
    Returns:
        Dict[str, Any]: 자막 통계 정보
    """
    try:
        stats = {}
        
        # 전체 자막 수
        total_count = fetch_one("SELECT COUNT(*) as count FROM subtitles")
        stats["total_count"] = total_count["count"] if total_count else 0
        
        # 언어별 자막 수
        lang_counts = fetch_all("SELECT lang, COUNT(*) as count FROM subtitles GROUP BY lang ORDER BY count DESC")
        stats["lang_counts"] = lang_counts or []
        
        # 미디어별 자막 수
        media_counts = fetch_all("""
            SELECT m.id, m.path, COUNT(s.id) as subtitle_count 
            FROM media m 
            LEFT JOIN subtitles s ON m.id = s.media_id 
            GROUP BY m.id 
            ORDER BY subtitle_count DESC 
            LIMIT 10
        """)
        stats["media_counts"] = media_counts or []
        
        return stats
        
    except Exception as e:
        logger.error(f"자막 통계 정보 조회 중 오류 발생: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return {}

def get_subtitle_length_distribution() -> List[Dict[str, Any]]:
    """
    자막 길이 분포 반환
    
    Returns:
        List[Dict[str, Any]]: 자막 길이 분포 (구간별 개수)
    """
    try:
        # 자막 길이에 따른 분포 계산
        sql = """
            SELECT 
                CASE 
                    WHEN LENGTH(content) <= 10 THEN '0-10'
                    WHEN LENGTH(content) <= 20 THEN '11-20'
                    WHEN LENGTH(content) <= 30 THEN '21-30'
                    WHEN LENGTH(content) <= 50 THEN '31-50'
                    WHEN LENGTH(content) <= 100 THEN '51-100'
                    ELSE '100+'
                END as length_range,
                COUNT(*) as count
            FROM subtitles
            GROUP BY length_range
            ORDER BY 
                CASE length_range
                    WHEN '0-10' THEN 1
                    WHEN '11-20' THEN 2
                    WHEN '21-30' THEN 3
                    WHEN '31-50' THEN 4
                    WHEN '51-100' THEN 5
                    ELSE 6
                END
        """
        
        results = fetch_all(sql)
        return results or []
        
    except Exception as e:
        logger.error(f"자막 길이 분포 조회 중 오류 발생: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return []
